---
title: "H5N1 modeling with age mixing data: Davis County example"
format: gfm
params:
  nthreads: 4L
  nsims: 20L
  R0: 1.1
  quarantine: TRUE
  isolation: TRUE
  pep: TRUE
---

```{r}
#| label: checking-params
#| echo: false

knitr::opts_chunk$set(echo = FALSE)

if (!exists("params")) {
  params <- list(
    nthreads = 10L,
    nsims = 20L,
    R0 = 1.9,
    quarantine = TRUE,
    isolation = TRUE,
    pep = TRUE
  )
}
```

```{r}
library(epiworldR)
library(data.table)
library(ggplot2)
```

## Data preparation

Setting up an empty model for the moment, we will be using the data from the davis county:

```{r}
#| label: loading-data
davis_pop <- fread("data/davis_population.csv")
davis_pop
```

Looking into the data

```{r}
plot(
  davis_pop$agepops,
  x = davis_pop$agelims,
  xlab = "Age groups",
  ylab = "Population counts",
  main = "Davis County Population by Age Groups"
)

N <- sum(davis_pop$agepops)
```

We can take a look at the mixing matrix

```{r}
davis_mixing_matrix <- readRDS("data/davis_mixing_matrix.rds")
image(
  davis_mixing_matrix,
  xlab = "Age groups",
  ylab = "Age groups",
  main = "Davis County Mixing Matrix"
)
```

The image shows a big diagonal in the middle which is expected as school-age individuals will contact mostly with their peers (most of the groups we have are schools). 

## Model creating

Se will be assuming two values

- Incubation period is 2 to 5 days.
- Basic reproductive number will be between 1.5 and 3.

To compute the basic reproductive number, we use the following:

```{r}
#| label: calibration
p_transmission <- 0.2
p_recovery <- 1/6
contact_rate <- params$R0 * p_recovery / p_transmission

# Figuring out if isolation and quarantine are enabled
quarantine_willingness <- ifelse(params$quarantine, 1.0, 0.0)
isolation_willingness  <- ifelse(params$isolation, 1.0, 0.0)
```

```{r}
#| label: creating-model
davis_model <- ModelSEIRMixingQuarantine(
  name                         = "Davis county",
  n                            = N,
  prevalence                   = 1/N,
  contact_rate                 = contact_rate,
  transmission_rate            = p_transmission,
  incubation_days              = 1.5,
  recovery_rate                = p_recovery,
  contact_matrix               = davis_mixing_matrix,
  hospitalization_rate         = 0.01,
  hospitalization_period       = 4,
  days_undetected              = 3, 
  quarantine_period            = 14,
  quarantine_willingness       = quarantine_willingness,
  isolation_willingness        = isolation_willingness,
  isolation_period             = 5,
  contact_tracing_success_rate = 0.8,
  contact_tracing_days_prior   = 7
)
```

We now start adding some of the entities from the population data:

```{r}
#| label: adding-entities
add_entities_from_dataframe(
  model = davis_model,
  entities = davis_pop,
  col_name = "age_labels",
  col_number = "agepops",
  as_proportion = FALSE
)
```

Ensuring that the virus starts at a school similar to that of the case

```{r}
#| label: seeding-virus
# The target school has about 986 students
idx <- davis_pop[,which(abs(agepops - 968) < 10)][1]
preval <- numeric(nrow(davis_pop))
preval[idx] <- 1 

dist_fun <- distribute_virus_to_entities(
  prevalence = preval,
  as_proportion = FALSE
)

get_virus(davis_model, 0) |>
  set_distribution_virus(dist_fun)

```

Checking if the model includes post-exposure prophylaxis (PEP)

```{r}
#| label: pep-check
if (params$pep) {

  # Creating the corresponding flag for the tool
  add_tool(
    davis_model,
    tool(
      name = "Post Exposure Prophylaxis",
      prevalence = .3,
      as_proportion = TRUE,
      susceptibility_reduction = 0.5,
      transmission_reduction = 0.8,
      recovery_enhancer = 0.0,
      death_reduction = 0.0
    )
  )
  
}
```

Running the model

```{r}
#| label: running-model
# Check if the model has already been run for this scenario
fn_rds <- sprintf(
  "R0_%.1f_isolation_%s_quarantine_%s_pep_%s.rds",
  params$R0,
  ifelse(params$isolation, "yes", "no"),
  ifelse(params$quarantine, "yes", "no"),
  ifelse(params$pep, "yes", "no")
  )

if (file.exists(fn_rds)) {
  # We just run it once
  run(davis_model, ndays = 100, seed = 8812)
} else {
  davis_model |>
    run_multiple(
      ndays = 100,
      nsims = params$nsims,
      seed  = 8812,
      saver = make_saver("outbreak_size", "hospitalizations", "reproductive"),
      nthreads =params$nthreads
    )
}
```

Looking at the single simulation results

```{r}
#| label: model-summary
summary(davis_model)
```

```{r}
#| label: run_multiple_get_results
# Extracting the results
if (file.exists(fn_rds)) {
  ans <- readRDS(fn_rds)
} else {
  ans <- davis_model |>
    run_multiple_get_results(
      freader = data.table::fread
    )

  # Taking a look at the structure
  str(ans)

  # Saving it
  saveRDS(ans, file = fn_rds)
}
```

We want to check that the index case is effectively one within the school (entity 13):

```{r}
#| label: checking-index-case
index_cases <- ans$reproductive[
  (source_exposure_date == 0) & (source != -1)
  ]$source

# This all should be TRUE
index_lb_up <- davis_pop[, cumsum(agepops)][idx + c(-1,0)]
table(index_cases < index_lb_up[2] & index_cases > index_lb_up[1])
```

We can also look at the distribution of the reproductive number for the index case

```{r}
#| label: index-case-r0
index_cases <- ans$reproductive[
  (source_exposure_date == 0) & (source != -1)
  ]

r0s <- table(index_cases$rt) |> prop.table() |> addmargins()
data.table(
  Rt = names(r0s),
  Probability = as.numeric(r0s)
) |> knitr::kable(
  caption = paste(
    "Reproductive number distribution for the index case",
    "(Average R0:", round(mean(index_cases$rt), 2), ")"
  ),
  col.names = c("R0", "Probability")
)
```

The function call will get us the results as a list of data.frames (data.table objects in this case). We will use the `data.table` package to manipulate the information.

```{r}
#| label: data.table
# Converting into data.table format for convenience
outbreak_size <- ans$outbreak_size |> as.data.table()
hospitalizations <- ans$hospitalizations |> as.data.table()
```

## Outbreak size

Finally, since we are only interested about the final outbreak size (in this case), can will collapse the data to get the total number of cases at the final simulation day. Subsequently, we can plot the results using the `hist` function:

```{r}
#| label: timeline-outbreak-size

if (interactive())
  png("timeline_outbreak_size.png", width = 500, height = 500)
# Aggregating to get the final
with(
  outbreak_size,
  {
    plot(
      x = date,
      y = jitter(outbreak_size),
      col = adjustcolor("blue", alpha.f = .05),
      lwd = 2,
      pch = 20,
      ylab = "Cases (log-scale)",
      xlab = "Day",
      main = "H5N1 outbreak size in Davis County",
      sub = "Mixing model with age and school data (100 simulations)",
      log = "y"
    )
})

if (interactive())
  dev.off()
```

We can also investigate the distribution of the final counts

```{r}
#| label: hist-outbreak-size
# Aggregating to get the final
if (interactive())
  png("hist_outbreak_size.png", width = 500, height = 500)

ggplot(outbreak_size[date == max(date)], aes(x = outbreak_size)) +
  geom_histogram(bins = 20, fill = "blue", color = "black", alpha = 0.7) +
  scale_x_log10() +
  labs(
    title = "H5N1 outbreak size in Davis County",
    subtitle = "Mixing model with age and school data (100 simulations)",
    x = "Cases (log-scale)",
    y = "Frequency"
  ) +
  theme_minimal()
# with(
#   outbreak_size[date == max(date)],
#   {
#     hist(
#       log(outbreak_size),
#       main = "H5N1 outbreak size in Davis County",
#       sub = "Mixing model with age and school data",
#       breaks = 20,
#       xlab = "Cases (log-scale)",
#     )
# })

if (interactive())
  dev.off()
```

```{r}
#| label: alt-representation
#| results: asis
outbreak_tot <- outbreak_size[
  date == max(date), .(total = sum(outbreak_size)), by = sim_num
  ]

# Creating a table showing the probability of these events
sizes <- c(10, 20, 50, 100, 200, 500, 1000, 2000)

knitr::kable(
  data.table(
    "Size" = sizes,
    "P(Greater or equal)" = sapply(sizes, function(sz) mean(outbreak_tot$total >= sz)),
    "P(Less or equal)" = sapply(sizes, function(sz) mean(outbreak_tot$total <= sz))
  ),
  caption = "Probability of outbreak sizes in Davis County",
  digits = 2
)
```

<!-- ## Hospitalizations

In the case of the hospitalizations, we can draw a similar figure. The hospitalizations data contains the following information:

1. Cases per virus (just measles in this case).
2. Cases per tool (or the lack of). Information about "no tool" is recorded with a `tool_id == -1`.
3. The counts (how many records in the data).
4. Weights.

The weights attribute is to ensure that we take into consideration counting individuals more than once. For instance, if a model has more than one tool (not just vaccination), the individual who has two tools would be included twice in `count`. Thus, if we wanted to count the raw number of hospitalization cases, we would add across `weight`, but the `count` variable yields how many individuals were hospitalized under that combination of tool and virus id.


```{r}
#| label: hospitalizations
if (nrow(hospitalizations) > 0) {
  hosp_tot <- hospitalizations[, .(total = sum(count)), by = .(sim_num, tool_id)]
  hosp_tot[, status := fifelse(tool_id == -1, "Unvax", "Vax")]
  hosp_tot[, tool_id := NULL]
}
```

We can create a couple of boxplot to show how many cases we see per vaccination status:

```{r}
#| label: summary-hosp
if (nrow(hospitalizations) > 0) {
  hosp_tot <- merge(
    hosp_tot[status == "Unvax", .(sim_num, unvax = total)],
    hosp_tot[status == "Vax", .(sim_num, vax = total)],
    all = TRUE
  )

  # Filling zeros
  hosp_tot[, unvax := fcoalesce(unvax, 0L)]
  hosp_tot[, vax := fcoalesce(vax, 0L)]

  hosp_tot[, .(vax, unvax)] |>
    as.matrix() |>
    boxplot(
      ylab = "Count",
      xlab = "Status",
      main = "Hospitalization per vaccination status",
      sub  = "Mixing model with age and school data (100 simulations)"
    )
}
```

## Final comments
 -->
