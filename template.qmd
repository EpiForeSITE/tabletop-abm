---
title: "Disease modeling with age mixing data: Davis County example"
format: gfm
params:
  nthreads: 4L
  nsims: 20L
  R0: 1.1
  quarantine: TRUE
  isolation: TRUE
---

```{r}
#| label: checking-params
if (!exists("params")) {
  params <- list(
    nthreads = 4L,
    nsims = 20L,
    R0 = 1.1,
    quarantine = TRUE,
    isolation = TRUE
  )
}
```

```{r}
library(epiworldR)
library(data.table)
```

## Data preparation

Setting up an empty model for the moment, we will be using the data from the davis county:

```{r}
#| label: loading-data
davis_pop <- fread("data/davis_population.csv")
davis_pop
```

Looking into the data

```{r}
plot(
  davis_pop$agepops,
  x = davis_pop$agelims,
  xlab = "Age groups",
  ylab = "Population counts",
  main = "Davis County Population by Age Groups"
)

N <- sum(davis_pop$agepops)
```

We can take a look at the mixing matrix

```{r}
davis_mixing_matrix <- readRDS("data/davis_mixing_matrix.rds")
image(
  davis_mixing_matrix,
  xlab = "Age groups",
  ylab = "Age groups",
  main = "Davis County Mixing Matrix"
)
```

The image shows a big diagonal in the middle which is expected as school-age individuals will contact mostly with their peers (most of the groups we have are schools). 

## Model creating

Se will be assuming two values

- Incubation period is 2 to 5 days.
- Basic reproductive number will be between 1.5 and 3.

To compute the basic reproductive number, we use the following:

```{r}
p_transmission <- 0.2
p_recovery <- 1/6
contact_rate <- params$R0 * p_recovery / p_transmission

# Figuring out if isolation and quarantine are enabled
quarantine_willingness <- ifelse(params$quarantine, 1.0, 0.0)
isolation_willingness  <- ifelse(params$isolation, 1.0, 0.0)
```

```{r}
#| label: creating-model
davis_model <- ModelSEIRMixingQuarantine(
  name                         = "Davis county",
  n                            = N,
  prevalence                   = 1/N,
  contact_rate                 = contact_rate,
  transmission_rate            = p_transmission,
  incubation_days              = 1.5,
  recovery_rate                = p_recovery,
  contact_matrix               = davis_mixing_matrix,
  hospitalization_rate         = 0.01,
  hospitalization_period       = 4,
  days_undetected              = 3, 
  quarantine_period            = 14,
  quarantine_willingness       = quarantine_willingness,
  isolation_willingness        = isolation_willingness,
  isolation_period             = 5,
  contact_tracing_success_rate = 0.8,
  contact_tracing_days_prior   = 7
)
```

We now start adding some of the entities from the population data:

```{r}
add_entities_from_dataframe(
  model = davis_model,
  entities = davis_pop,
  col_name = "age_labels",
  col_number = "agepops",
  as_proportion = FALSE
)
```

Running the model

```{r}
davis_model |>
  run_multiple(
    ndays = 100,
    nsims = params$nsims,
    seed  = 8812,
    saver = make_saver("outbreak_size", "hospitalizations", "reproductive"),
    nthreads =params$nthreads
  )
```

Looking at the single simulation results

```{r}
summary(davis_model)
```

```{r}
#| label: run_multiple_get_results
# Extracting the results
ans <- davis_model |>
  run_multiple_get_results(
    freader = data.table::fread
  )

# Taking a look at the structure
str(ans)

# Saving it
saveRDS(
  ans,
  file = sprintf(
    "R0_%.1f_isolation_%s_quarantine_%s.rds",
    params$R0,
    ifelse(params$isolation, "yes", "no"),
    ifelse(params$quarantine, "yes", "no")  
    )
)
```

The function call will get us the results as a list of data.frames (data.table objects in this case). We will use the `data.table` package to manipulate the information.

```{r}
#| label: data.table
# Converting into data.table format for convenience
outbreak_size <- ans$outbreak_size |> as.data.table()
hospitalizations <- ans$hospitalizations |> as.data.table()
```

## Outbreak size

Finally, since we are only interested about the final outbreak size (in this case), can will collapse the data to get the total number of cases at the final simulation day. Subsequently, we can plot the results using the `hist` function:

```{r}
#| label: timeline-outbreak-size
# Aggregating to get the final
with(
  outbreak_size,
  {
    plot(
      x = date,
      y = outbreak_size,
      col = adjustcolor("blue", alpha.f = .2),
      pch = 19,
      ylab = "Cases",
      xlab = "Day",
      main = "Disease outbreak size in Davis County",
      sub = "Mixing model with age and school data (100 simulations)"
    )
})
```

We can also investigate the distribution of the final counts

```{r}
#| label: hist-outbreak-size
# Aggregating to get the final
with(
  outbreak_size[date == max(date)],
  {
    hist(
      outbreak_size,
      main = "Disease outbreak size in Davis County",
      sub = "Mixing model with age and school data",
      breaks = 20
    )
})
```

```{r}
#| label: alt-representation
outbreak_tot <- outbreak_size[
  date == max(date), .(total = sum(outbreak_size)), by = sim_num
  ]

# Creating a table showing the probability of these events
sizes <- c(10, 20, 50, 100, 200, 500, 1000, 2000)
sapply(sizes, function(sz) mean(outbreak_tot$total >= sz))

knitr::kable(
  data.table(
    "Size" = sizes,
    "P(Greater or equal)" = sapply(sizes, function(sz) mean(outbreak_tot$total >= sz)),
    "P(Less or equal)" = sapply(sizes, function(sz) mean(outbreak_tot$total <= sz))
  ),
  caption = "Probability of outbreak sizes in Davis County",
  digits = 2
)
```

## Hospitalizations

In the case of the hospitalizations, we can draw a similar figure. The hospitalizations data contains the following information:

1. Cases per virus (just measles in this case).
2. Cases per tool (or the lack of). Information about "no tool" is recorded with a `tool_id == -1`.
3. The counts (how many records in the data).
4. Weights.

The weights attribute is to ensure that we take into consideration counting individuals more than once. For instance, if a model has more than one tool (not just vaccination), the individual who has two tools would be included twice in `count`. Thus, if we wanted to count the raw number of hospitalization cases, we would add across `weight`, but the `count` variable yields how many individuals were hospitalized under that combination of tool and virus id.


```{r}
#| label: hospitalizations
if (nrow(hospitalizations) > 0) {
  hosp_tot <- hospitalizations[, .(total = sum(count)), by = .(sim_num, tool_id)]
  hosp_tot[, status := fifelse(tool_id == -1, "Unvax", "Vax")]
  hosp_tot[, tool_id := NULL]
}
```

We can create a couple of boxplot to show how many cases we see per vaccination status:

```{r}
#| label: summary-hosp
if (nrow(hospitalizations) > 0) {
  hosp_tot <- merge(
    hosp_tot[status == "Unvax", .(sim_num, unvax = total)],
    hosp_tot[status == "Vax", .(sim_num, vax = total)],
    all = TRUE
  )

  # Filling zeros
  hosp_tot[, unvax := fcoalesce(unvax, 0L)]
  hosp_tot[, vax := fcoalesce(vax, 0L)]

  hosp_tot[, .(vax, unvax)] |>
    as.matrix() |>
    boxplot(
      ylab = "Count",
      xlab = "Status",
      main = "Hospitalization per vaccination status",
      sub  = "Mixing model with age and school data (100 simulations)"
    )
}
```

## Final comments

